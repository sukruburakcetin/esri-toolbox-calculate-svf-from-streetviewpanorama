# googlestreetview_to_fisheye.pyt @19.09.2025 by sukruburakcetinimport arcpyimport osimport timeimport requestsfrom PIL import Imageimport numpy as npimport cv2from scipy.ndimage import binary_opening, generate_binary_structure, binary_fill_holesfrom segment_anything import sam_model_registry, SamPredictorimport matplotlib.pyplot as pltclass Toolbox(object):    def __init__(self):        self.label = "Street View Panorama Toolbox"        self.alias = "streetview"        self.tools = [DownloadPanorama]class DownloadPanorama(object):    def __init__(self):        self.label = "Calculate SVF From Street View Panorama"        self.description = "Download panorama, create fisheye, and add point to map."        self.canRunInBackground = False    def getParameterInfo(self):        params = []        panoid = arcpy.Parameter(            displayName="Panoid",            name="panoid",            datatype="GPString",            parameterType="Required",            direction="Input")        lat = arcpy.Parameter(            displayName="Latitude",            name="latitude",            datatype="GPDouble",            parameterType="Required",            direction="Input")        lon = arcpy.Parameter(            displayName="Longitude",            name="longitude",            datatype="GPDouble",            parameterType="Required",            direction="Input")        zoom = arcpy.Parameter(            displayName="Zoom Level",            name="zoom",            datatype="GPLong",            parameterType="Optional",            direction="Input")        zoom.value = 2        out_folder = arcpy.Parameter(            displayName="Output Folder",            name="out_folder",            datatype="DEFolder",            parameterType="Required",            direction="Input")        params.extend([panoid, lat, lon, zoom, out_folder])        return params    def crop_image_upper_half(self, img_path, output_path, quality=100):        """        Crop the upper half of the image and save it.        """        img = Image.open(img_path)        width, height = img.size        new_height = height // 2        cropped_img = img.crop((0, 0, width, new_height))        cropped_img.save(output_path, quality=quality)        return output_path    def remove_background(self, img):        """        Make the area outside the central circle transparent.        """        height, width, channels = img.shape        radius = min(height, width) // 2        mask = np.zeros((height, width), dtype=np.uint8)        cv2.circle(mask, (width // 2, height // 2), radius, 255, thickness=-1)        # Apply mask and convert to BGRA        circular_img = cv2.cvtColor(img, cv2.COLOR_BGR2BGRA)        circular_img[:, :, 3] = mask  # alpha channel        return circular_img    def execute(self, parameters, messages):        panoid = parameters[0].valueAsText        lat = float(parameters[1].value)        lon = float(parameters[2].value)        zoom = int(parameters[3].value)        out_dir = parameters[4].valueAsText        # Download and stitch panorama        pano_file, folder = self.download_panorama(panoid, zoom, out_dir)        messages.addMessage(f"Panorama saved: {pano_file}")        panorama_projections_dir = os.path.join(out_dir, folder)        # Crop upper half        cropped_file = os.path.join(panorama_projections_dir, f"panorama_{panoid}_z{zoom}_upper.png")        self.crop_image_upper_half(pano_file, cropped_file)        messages.addMessage(f"Cropped panorama saved: {cropped_file}")        # Convert to fisheye        fisheye_file = self.panoramic_to_fisheye(cropped_file, panorama_projections_dir, panoid, zoom)        messages.addMessage(f"Fisheye saved: {fisheye_file}")        gdb_path = os.path.join(out_dir, "Panorama.gdb")        fc_name = "Panoramas"        fc = os.path.join(gdb_path, fc_name)        # Ensure GDB exists        if not arcpy.Exists(gdb_path):            gdb_path = arcpy.management.CreateFileGDB(out_dir, "Panorama.gdb").getOutput(0)        # Ensure feature class exists        if not arcpy.Exists(fc):            fc = arcpy.management.CreateFeatureclass(                gdb_path, fc_name, "POINT", spatial_reference=4326            ).getOutput(0)            arcpy.management.AddField(fc, "PANOID", "TEXT")            arcpy.management.AddField(fc, "PANORAMA", "TEXT")            arcpy.management.AddField(fc, "FISHEYE", "TEXT")            arcpy.management.AddField(fc, "FISHEYE_CROPPED", "TEXT")            arcpy.management.AddField(fc, "MASK", "TEXT")            arcpy.management.AddField(fc, "SVF", "DOUBLE")        # Correct fields (do NOT include "OID@")        fields = ["SHAPE@XY", "PANOID", "PANORAMA", "FISHEYE", "FISHEYE_CROPPED", "MASK"]        # Insert the row and capture OID        with arcpy.da.InsertCursor(fc, fields) as cursor:            cursor.insertRow(((lon, lat), panoid, pano_file, fisheye_file, "", ""))        # Now get the OID of the inserted row        with arcpy.da.SearchCursor(fc, ["OID@"], "PANOID = '{}'".format(panoid)) as search_cursor:            oid = [row[0] for row in search_cursor][0]        # Calculate SVF        svf_value, final_mask_path, fisheye_cropped_path = self.calculate_svf(fisheye_file, fc, oid)        # Update the same row with SVF        with arcpy.da.UpdateCursor(fc, ["OID@", "SVF", "MASK", "FISHEYE_CROPPED"]) as cursor:            for row in cursor:                if row[0] == oid:                    row[1] = svf_value                    row[2] = final_mask_path                    row[3] = fisheye_cropped_path                    cursor.updateRow(row)                    break        messages.addMessage(f"SVF calculated and stored: {svf_value}")        # Add layer only if not already present        aprx = arcpy.mp.ArcGISProject("CURRENT")        m = aprx.activeMap        layer_names = [lyr.name for lyr in m.listLayers()]        if fc_name not in layer_names:            m.addDataFromPath(fc)        messages.addMessage(f"Feature class created: {fc}")    # ---------------------------    # Panorama download function    # ---------------------------    def download_panorama(self, panoid, zoom, out_dir, delay=0.1):        cols = 2 ** zoom        rows = 2 ** (zoom - 1)        folder = os.path.join(out_dir, f"{panoid}_z{zoom}")        os.makedirs(folder, exist_ok=True)        for x in range(cols):            for y in range(rows):                url = f"https://streetviewpixels-pa.googleapis.com/v1/tile?cb_client=maps_sv.tactile&panoid={panoid}&x={x}&y={y}&zoom={zoom}&nbt=1&fover=2"                tile_path = os.path.join(folder, f"tile_{x}_{y}.jpg")                if not os.path.exists(tile_path):                    r = requests.get(url, stream=True)                    if r.status_code == 200:                        with open(tile_path, "wb") as f:                            f.write(r.content)                time.sleep(delay)        # Check if first tile exists        first_tile = os.path.join(folder, "tile_0_0.jpg")        if not os.path.exists(first_tile):            raise FileNotFoundError("No tiles downloaded for this panoid/zoom.")        # Stitch        sample = Image.open(first_tile)        w, h = sample.size        pano = Image.new("RGB", (cols * w, rows * h))        for x in range(cols):            for y in range(rows):                tile_path = os.path.join(folder, f"tile_{x}_{y}.jpg")                if os.path.exists(tile_path):                    tile = Image.open(tile_path)                    pano.paste(tile, (x * w, y * h))        out_file = os.path.join(folder, f"panorama_{panoid}_z{zoom}.png")        pano.save(out_file)        return out_file, folder    # ---------------------------    # Convert panorama to fisheye    # ---------------------------    def panoramic_to_fisheye(self, pano_file, out_dir, panoid, zoom):        # Load panorama using OpenCV        panoramic_image = cv2.imread(pano_file)        h, w = panoramic_image.shape[:2]        fisheye_height = min(h, w)        fisheye_width = fisheye_height * 2        fisheye_image = np.zeros((fisheye_height, fisheye_width, 3), dtype=np.uint8)        center_x = fisheye_width // 2        center_y = fisheye_height // 2        radius = min(center_x, center_y)        mask = np.zeros((fisheye_height, fisheye_width), dtype=np.uint8)        cv2.circle(mask, (center_x, center_y), radius, 255, -1)        for y in range(fisheye_height):            for x in range(fisheye_width):                if mask[y, x] == 255:                    theta = np.arctan2(y - center_y, x - center_x)                    rho = np.sqrt((x - center_x) ** 2 + (y - center_y) ** 2)                    panoramic_x = int((theta / np.pi + 1) * (w / 2))                    panoramic_y = int((rho / radius) * h)                    panoramic_x = min(max(panoramic_x, 0), w - 1)                    panoramic_y = min(max(panoramic_y, 0), h - 1)                    fisheye_image[y, x] = panoramic_image[panoramic_y, panoramic_x]         # Make outside circular area transparent        fisheye_image = self.remove_background(fisheye_image)        fisheye_file = os.path.join(out_dir, f"fisheye_{panoid}_z{zoom}.png")        cv2.imwrite(fisheye_file, fisheye_image)        return fisheye_file    def calculate_svf(self, fisheye_file, feature_class, oid):        """        Calculate SVF from fisheye image and update feature row.        """        # Load fisheye and crop to square        img = Image.open(fisheye_file)        width, height = img.size        new_width = height        left = (width - new_width) / 2        right = width - left        img_cropped = img.crop((left, 0, right, height))        cropped_path = fisheye_file.replace(".png", "_cropped.png")        img_cropped.save(cropped_path)        # Convert for SAM        img_cropped_final = cv2.imread(cropped_path)        image = cv2.cvtColor(img_cropped_final, cv2.COLOR_BGR2RGB)        # Load SAM model        sam_checkpoint = os.path.join(os.path.dirname(__file__), "models", "sam_vit_h_4b8939.pth")        model_type = "vit_h"        device = "cuda"        sam = sam_model_registry[model_type](checkpoint=sam_checkpoint)        sam.to(device=device)        mask_predictor = SamPredictor(sam)        mask_predictor.set_image(image)        # Get cropped image size        h, w, _ = image.shape        # Always choose the center        center_x = w // 2        center_y = h // 2        input_point = np.array([[w // 2, h // 2]])  # center point        input_label = np.array([1])        masks, scores, logits = mask_predictor.predict(            point_coords=input_point,            point_labels=input_label,            multimask_output=False,        )        # Post-process mask        mask = masks[0].astype(np.uint8)        mask_8bit = (mask * 255).astype(np.uint8)        filled_image = binary_fill_holes(mask_8bit)        structuring_element = generate_binary_structure(2, 1)        cleaned_image = binary_opening(filled_image, structure=structuring_element)        # Generate a circular mask matching image size        Y, X = np.ogrid[:h, :w]        dist = np.sqrt((X - w // 2) ** 2 + (Y - h // 2) ** 2)        circular_mask = (dist <= min(h, w) // 2).astype(np.uint8) * 255        # Convert both to RGBA        binary_img = Image.fromarray(np.uint8(cleaned_image) * 255).convert("RGBA")        mask_img = Image.fromarray(circular_mask).convert("L")  # single channel mask        # Apply circular mask        output_img = Image.composite(binary_img, Image.new("RGBA", binary_img.size, (0, 0, 0, 0)), mask_img)        final_mask_path = fisheye_file.replace(".png", "_mask.png")        output_img.save(final_mask_path)        # Convert mask to binary        gray_image = output_img.convert('L')        binary_image = np.array(gray_image) > 128        # SVF computation        h, w = binary_image.shape        center_x, center_y = w // 2, h // 2        radius = min(center_x, center_y)        Y, X = np.ogrid[:h, :w]        dist_from_center = np.sqrt((X - center_x) ** 2 + (Y - center_y) ** 2)        n = 36        rings = np.linspace(0, radius, n + 1)        svf = 0        for i in range(1, n + 1):            ring_mask = (dist_from_center >= rings[i - 1]) & (dist_from_center < rings[i])            if np.any(ring_mask):                sky_pixels = np.sum(binary_image[ring_mask])                total_pixels = np.sum(ring_mask)                p_i = sky_pixels / total_pixels                svf += np.sin(np.pi * (2 * i - 1) / (2 * n)) * p_i        svf *= (np.pi / (2 * n))        # Update feature class row with SVF        import arcpy        with arcpy.da.UpdateCursor(feature_class, ["OID@", "svf"]) as cursor:            for row in cursor:                if row[0] == oid:                    row[1] = svf                    cursor.updateRow(row)                    break        return svf, final_mask_path, cropped_path